# Developer interface

There are two main ways to interact with Wire using the SDK:
1. Reacting to received events by subclassing `WireEventsHandler`
2. Triggering actions using the `WireApplicationManager`

---

## Reacting to events
The SDK receives events continuosly after you use `startListening()`. 
The http connection, deserialization, authentication and decrypting are performed by the Application, so you will receive the event as a `WireMessage`.

You can handle different events and perform any action you want. This is done inside the method override of `WireEventsHandler`. When you create a class to subclass the `WireEventsHandler`, inside each event you have access to a field called `manager` of type `WireApplicationManager`.

The manager allows you to interact with Wire, from creating conversations, fetching users to sending messages.
You can use it while receiving events and/or directly use it directly in your code (e.g a scheduled job uses `WireApplicationManager` to fetch conversations, or a webhook you create triggers a message being sent in Wire).

Check all the events in [Wire Events](../04-events/index.md)

---

## Functionalities of the SDK

`WireApplicationManager` has two versions of each function, one "suspending" and the other in normal blocking fashion.
If you are using Java just look at the non-suspending methods, while in Kotlin you can choose to leverage coroutines (with suspending functions) or not.

Here are some example of things you can do via the SDK to interact with the Wire ecosystem with your App:

### Managing Teams and Conversations

The SDK provides access to teams and conversations through the `WireApplicationManager`, available after initializing the `WireAppSDK`

```kotlin
val applicationManager = wireAppSdk.getApplicationManager()

// Get all teams the application has been invited to
val teams = applicationManager.getStoredTeams()
teams.forEach { teamId ->
    println("Team: $teamId")
}

// Get all conversations the application has access to
val conversations = applicationManager.getStoredConversations()
conversations.forEach { conversation ->
    println("Conversation: ${conversation.id} in team: ${conversation.teamId}")
}

// Get application data
val appData = applicationManager.getApplicationData()
println("Application name: ${appData.name}")
```

### Sending Messages

You can make your application send messages to specific conversations.

For when you to send a message. It can be achieved when you have the conversation ID it needs to be sending a message.
```kotlin
val applicationManager = wireAppSdk.getApplicationManager()
applicationManager.sendMessageSuspending(
    message = WireMessage // All WireMessage event types are supported through this method
)
```
> **_Java:_**  Use `applicationManager.sendMessage`

For when you upload and send an asset (file) to a conversation.

Nots: When sending an asset message, you need to provide the file, name and mime type, while we take
care of the encryption and metadata based on file mime type.
```kotlin
// Get local File
val resourcePath = javaClass.classLoader.getResource("my-file.png")?.path
    ?: throw IllegalStateException("Test resource 'my-file.png' not found")
val asset = File(resourcePath)

// Get File data in ByteArray
val originalData = asset.readBytes()

// Send File with necessary parameters
applicationManager.sendAssetSuspending(
    conversationId = wireMessage.conversationId,
    asset = AssetResource(originalData),
    name = asset.name,
    mimeType = "image/png",
    retention = AssetRetention.ETERNAL
)
```
> **_Java:_**  Use `applicationManager.sendAsset`

### Creation of a Conversation

Through the WireApplicationManager (standalone or through events) you can create conversations (One to One or Group).
Here are an example for both on the standalone way:

```kotlin
val applicationManager = wireAppSdk.getApplicationManager()

// For Group Conversations there is no need to pass the App user Id as it will be added to the conversation by default.
val createdGroupConversationId = applicationManager.createGroupConversationSuspending(
    name = "Conversation Name",
    userIds = listOf(
        QualifiedId(userId1, userDomain1),
        QualifiedId(userId2, userDomain2)
    )
)

// For One to One Conversations you need to pass only the user whom the App will create the One to One conversation with.
val createdOneToOneConversationId = applicationManager.createOneToOneConversationSuspending(
    userId = QualifiedId(otherUserId, otherUserDomain)
)

// Channel Conversations are similar to Group Conversations, with the difference of passing the Team Id.
val createdChannelConversationId = applicationManager.createChannelConversationSuspending(
    name = "Channel Name",
    userIds = listOf(
        QualifiedId(userId1, userDomain1),
        QualifiedId(userId2, userDomain2)
    ),
    teamId = TeamId(value = UUID.fromString("my-team-id"))
)
```

> **_Java:_** Use `createGroupConversation` for Group Conversations

> **_Java:_** Use `createOneToOneConversation` for One to One Conversations