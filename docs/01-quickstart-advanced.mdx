# Developing App - JVM
This guide will help you create and understand how to develop and deploy a simple Wire Application written
in a JVM language (Java, Kotlin, Scala). The SDK you will be using will simplify encryption/decryption, and http client calls to the Wire backend, leaving you to care about your business logic.

Note that the SDK takes care of security in transit and partially for securing cryptographic data stored by the SDK in the filesystem. However, as you will have access to decrypted messages and identifiers of conversations and teams, it is up to you to secure them.

## Prerequisites

- Java 17 or higher
- Kotlin 2.x.x if you are using Kotlin
- An application registered with Wire (to obtain an API token)
- File system access for storing cryptographic keys and data

## Adding the SDK to Your Project

```mdx-code-block
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
```

<Tabs>
<TabItem value="gradle" label="Gradle">

```kotlin
dependencies {
    implementation("com.wire:wire-apps-jvm-sdk:0.0.1")
}
```

</TabItem>
<TabItem value="maven" label="Maven">

```xml
<dependency>
    <groupId>com.wire</groupId>
    <artifactId>wire-apps-jvm-sdk</artifactId>
    <version>0.0.1</version>
</dependency>
```
</TabItem>
</Tabs>

## Initializing the SDK

The SDK needs to be initialized with your application's credentials, the backend host, a password for the cryptographic material and your event handler implementation:

| Parameter                     | Description                                                                                                                                                                                |
|-------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `applicationId` + `apiToken`  | Retrieved from the backend during onboarding, when you register a new Application                                                                                                          |
| `apiHost`                     | The target backend, should be production for normal operations: https://prod-nginz-https.wire.com                                                                                          |
| `cryptographyStoragePassword` | The password you choose to let the SDK encrypt the cryptographic material at rest. It is recommended to be generated randomly and stored in a secure place. It must be 32 characters long. |
| `wireEventsHandler`           | Your implementation (extending the `WireEventsHandler` abstract class)                                                                                                                     |

#### Environment Variables
> For now (it will be changed in the future) the SDK also needs some environment variables of a User to act as the App
```dotenv
WIRE_SDK_USER_ID=abcd-1234-efgh-5678
WIRE_SDK_EMAIL=your_email@domain.com
WIRE_SDK_PASSWORD=dummyPassword
WIRE_SDK_ENVIRONMENT=my.domain.link
```

Initializing an instance of WireAppSdk is enough to get access to local stored teams and conversations and to send messages or similar actions.

However, to establish a long-lasting connection with the backend and receive all the events targeted to you Application, you need to call the `startListening()` method.
The `startListening()` method keeps a background thread running until explicitly stopped or the application terminates.


## Complete Example

Here's a complete example showing how to initialize the SDK and handle basic received events:

<Tabs groupId="programming-language">
<TabItem value="kotlin" label="Kotlin">

```kotlin
fun main() {
    val wireAppSdk = WireAppSdk(
        applicationId = UUID.fromString("YOUR_APPLICATION_ID"),
        apiToken = "YOUR_API_TOKEN",
        apiHost = "YOUR_API_HOST",
        cryptographyStoragePassword = "YOUR_32_CHAR_STORAGE_PASSWORD",
        object : WireEventsHandlerSuspending() {
            override suspend fun onTextMessageReceived(wireMessage: WireMessage.Text) {
                println("Text message received: $wireMessage")

                // Add your message handling logic here, like storing the message,
                //   sending back another message, or triggering some workflow
            }
        }
    )

    // Start the SDK
    wireAppSdk.startListening()
}
```

</TabItem>
<TabItem value="java" label="Java">

```java
public class Main {
    public static void main(String[] args) {
        final var wireAppSdk = new WireAppSdk(
            UUID.fromString("YOUR_APPLICATION_ID"),
            "YOUR_API_TOKEN",
            "YOUR_API_HOST",
            "YOUR_32_CHAR_STORAGE_PASSWORD",
            new WireEventsHandlerDefault() {
                @Override
                public void onTextMessageReceived(@NotNull WireMessage.Text wireMessage) {
                    System.out.println("Text message received: $wireMessage");

                    // Add your message handling logic here, like storing the message,
                    //   sending back another message, or triggering some workflow
                }
            }
        );

        // Start the SDK
        wireAppSdk.startListening();
    }
}
```

</TabItem>
</Tabs>
For simplicity the subclassing of WireEventsHandler is done inline as an anonymous class, but you can create a separate class for it,
especially if you handle events in a complex way:

<Tabs groupId="programming-language">
<TabItem value="kotlin" label="Kotlin">

```kotlin
class MyWireEventsHandler : WireEventsHandlerSuspending() {
    private val logger = LoggerFactory.getLogger(MyWireEventsHandler::class.java)

    override suspend fun onTextMessageReceived(wireMessage: WireMessage.Text) {
        logger.info("Text message received: $wireMessage")
    }
}
```

</TabItem>
<TabItem value="java" label="Java">

```java
public class MyWireEventsHandler extends WireEventsHandlerDefault {
    private static final Logger logger = LoggerFactory.getLogger(MyWireEventsHandler.class);

    @Override
    public void onTextMessageReceived(@NotNull WireMessage.Text wireMessage) {
        logger.info("Text message received: $wireMessage");
    }
}

```


**NOTE**: Your application can simply call `startListening()` and a new thread is created and will keep the Application running and receiving events. To stop it, just close the Application (Ctrl+C/Cmd+C) or call `stopListening()`

</TabItem>
</Tabs>
## Echoing a received message

In your `onTextMessageReceived` implementation from `MyWireEventsHandler` you can echo a message as:

<Tabs groupId="programming-language">
<TabItem value="kotlin" label="Kotlin">

```kotlin
override suspend fun onTextMessageReceived(wireMessage: WireMessage.Text) {
    val message = WireMessage.Text.createReply(
        conversationId = wireMessage.conversationId,
        text = "${wireMessage.text} -- Sent from the SDK",
        mentions = wireMessage.mentions,
        originalMessage = wireMessage
    )

    // The manager is accessible through the inherited WireEventsHandler class.
    // It is used to manage the Wire application's lifecycle and communication with the backend.
    manager.sendMessageSuspending(message = message)
}
```

</TabItem>
<TabItem value="java" label="Java">

```java
@Override
public void onTextMessageReceived(@NotNull WireMessage.Text wireMessage) {
    final WireMessage reply = WireMessage.Text.createReply(
            wireMessage.conversationId(),
            wireMessage.text() + " -- Sent from the SDK",
            wireMessage.mentions(),
            wireMessage.linkPreviews(),
            wireMessage,
            null);

    // The manager is accessible through the inherited WireEventsHandler class.
    // It is used to manage the Wire application's lifecycle and communication with the backend.
    getManager().sendMessage(reply);
}
```

</TabItem>
</Tabs>
## Conclusion

With this basic setup you now have a simple Wire App.

You can check other events in [Wire Events](04-events/index.md)

## Troubleshooting

- Enable DEBUG logging on the SDK if you are developing an Application and want to test it in a safe environment. Set the log level to DEBUG in your logging framework for the package `com.wire.sdk` (e.g. for Logback `<logger name="com.wire.sdk" level="DEBUG" />`).
- If you switch between different Wire environments, you may need to delete the `storage/apps.db` directory to avoid conflicts
- For connection issues, verify your API token, host URL and if your deployed app has access to the public network (firewalls, docker ports, etc.)
- When running into cryptography issues, ensure your storage password is consistent between app restarts
- The SDK is designed to be thread-safe. The `startListening()` and `stopListening()` methods are synchronized to prevent concurrent modifications to the SDK state. However at this moment, only using a single Wire Application instance has been tested.
- In case you need to build the SDK locally, you can skip the signing option by running: `./gradlew publishToMavenLocal -PskipSigning=true` (**_Keep in mind_** to include `repositories { mavenCentral() }` in your `build.gradle.kts` file in the app where you use the locally built SDK)

## Additional Resources

For any issue, requests or improvements, let us know by contacting us or creating a new issue on GitHub
